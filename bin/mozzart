#!/usr/bin/env node

'use strict';

const _ = require(`lodash`);
const config = require(`../lib/config`);
const pack = require(`../package.json`);
const startAll = require(`./startAll`);
const start = require(`./start`);
const listProcesses = require(`./list`);
const log = require(`../lib/log`);
const registry = require(`../lib/registry`);

const showVersion = () => {
  console.log(`mozzart@${pack.version}`);

  process.exit(0);
};

const resume = async uid => {
  log(`Starting ${uid}...`);
  const pid = await registry.getPid(uid);

  if (pid) { return log(`Already running`); }

  await registry.setAuto(uid, false);
  await registry.addResumeUid(uid);
  const mozzReg = await registry.get(`mozzart`);

  return process.kill(mozzReg.pid, `SIGCONT`);
};

const stop = async uid => {
  log(`Stopping ${uid}...`);
  await registry.setAuto(uid, false);
  const pid = await registry.getPid(uid);

  if (!pid) { return log(`Not running`); }

  try {
    process.kill(pid, `SIGKILL`);
  } catch (e) {}

  return Promise.resolve();
};

const restart = async uid => {
  await stop(uid);
  const isAuto = await registry.isAuto(uid);

  if (!isAuto) {
    setTimeout(() => resume(uid), 500);
  }
};

const remove = async (uid, silent = false) => {
  await stop(uid);
  log(`Removing ${uid}...`);
  await registry.addRemoveUid(uid);
  const mozzReg = await registry.get(`mozzart`);

  if (silent) { return Promise.resolve(); }

  return process.kill(mozzReg.pid, `SIGCONT`);
};

const addIdentifierToProc = proc => ({
  ...proc,
  $identifier : `${proc.cwd}/${proc.file}`,
});

const update = async () => {
  const mozzReg = await registry.get(`mozzart`);
  const currentProcesses = (await registry.getProcesses()).map(addIdentifierToProc);
  const configProcesses = config.processes.map(addIdentifierToProc);

  const processesToRemove = _.filter(currentProcesses, currentProcess =>
    !_.find(configProcesses, proc => proc.$identifier === currentProcess.$identifier)
  );

  const definitionsToAdd = _.filter(configProcesses, proc =>
    !_.find(currentProcesses, currentProcess => proc.$identifier === currentProcess.$identifier)
  );

  for (const proc of processesToRemove) { await remove(proc.uid); }
  for (const def of definitionsToAdd) { await registry.addStartDef(def, true); }

  return process.kill(mozzReg.pid, `SIGCONT`);
};

if (config.command === `showVersion`) {
  showVersion();
} else if (config.command === `start`) {
  startAll();
} else if (config.command === `resume`) {
  resume(config.uidForCmd);
} else if (config.command === `restart`) {
  restart(config.uidForCmd);
} else if (config.command === `stop`) {
  stop(config.uidForCmd);
} else if (config.command === `remove`) {
  remove(config.uidForCmd);
} else if (config.command === `update`) {
  update();
} else if (config.command === `listProcesses`) {
  listProcesses();
}

let isShuttingDown = false;

process.on(`SIGINT`, async () => {
  if (isShuttingDown) { return process.exit(1); }
  isShuttingDown = true;
  console.log(``); // eslint-disable-line // Line break
  log(`[mozzart] Shutting down all processes`);
  const processes = await registry.getProcesses();
  await Promise.all(
    processes.map(async process => {
      registry.locals.runningDefs[process.uid].isKilling = true;

      return stop(process.uid);
    })
  );
  await registry.clean();
  process.exit(0); // eslint-disable-line
});
